<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>/* byexample.xyz */</title>
    <link>https://byexample.xyz/</link>
    <description>Recent content on /* byexample.xyz */</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Mon, 01 Jan 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://byexample.xyz/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java 8 Convert Streams to &amp; from Arrays Examples</title>
      <link>https://byexample.xyz/java/8/streamtoandfromarray/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://byexample.xyz/java/8/streamtoandfromarray/</guid>
      <description>Converting from Streams to Arrays Converting a stream to an array is a simple task of using Stream&amp;rsquo;s toArray() method combined with a method references to the new array&amp;rsquo;s type.
For example here we want an array of type String[] so we use a method reference to String[]::new:
package xyz.byexample.java8; import java.util.stream.Stream; public class StreamsArrays { public static void main(String[] args) { Stream&amp;lt;String&amp;gt; stream = Stream.of(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;); String[] array = stream.</description>
    </item>
    
    <item>
      <title>Java 8 Convert Streams to &amp; from Lists Examples</title>
      <link>https://byexample.xyz/java/8/streamtoandfromlist/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://byexample.xyz/java/8/streamtoandfromlist/</guid>
      <description>Converting from Streams to Lists Converting a Stream to a List is extremely simple since we can use the stream&amp;rsquo;s collect() function with the Collectors.toList() built-in function like in the example below:
package xyz.byexample.java8; import java.util.List; import java.util.stream.Collectors; import java.util.stream.Stream; public class StreamToList { public static void main(String[] args) { Stream&amp;lt;Integer&amp;gt; numbersStream = Stream.of(1, 2, 3, 4, 5); List&amp;lt;Integer&amp;gt; numbersList = numbersStream.collect(Collectors.toList()); numbersList.forEach(number -&amp;gt; System.out.println(number)); } } Output
1 2 3 4 5  Converting from Lists to Streams Again, converting a List to a Stream is extremely simple thanks to the built-in functions stream() and parallelStream() on the List type.</description>
    </item>
    
    <item>
      <title>Java 8 Default Method Examples</title>
      <link>https://byexample.xyz/java/8/default/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://byexample.xyz/java/8/default/</guid>
      <description>Default Methods provide a way to provide a default implementation for a method in an interface. By providing a default implementation, you can add new methods to your interface without breaking backwards compatibility for existing code that already implements your interfaces.
 In the old-days, if you changed an interface then all code that implemented that interface would need to be updated to implement the new method.
In a project you were working on this might have required changing code all over your project which could have been be a real pain if your project was large.</description>
    </item>
    
    <item>
      <title>Java 8 Functional Interfaces Examples</title>
      <link>https://byexample.xyz/java/8/functionalinterfaces/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://byexample.xyz/java/8/functionalinterfaces/</guid>
      <description>Functional Interfaces in Java 8 are the key to unlocking the power of the new lambda expressions and method references.
Whenever we use a lambda expression (e.g. when creating an anonymous function when we&amp;rsquo;re working with streams), our expression has to satisfy one of these functional interfaces to be accepted - to think of it another way, our function has to match the &amp;ldquo;pattern&amp;rdquo; or &amp;ldquo;shape&amp;rdquo; that Java is expecting.</description>
    </item>
    
    <item>
      <title>Java 10 Local Type Inference</title>
      <link>https://byexample.xyz/java/10/localinference/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://byexample.xyz/java/10/localinference/</guid>
      <description>Local Type Inference Example In the past, we needed to repeat ourselves a lot when doing obvious things, for example here we have to declare the type of variable, even though it is obvious to both us and java:
List&amp;lt;String&amp;gt; variable = List.of(&amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;C&amp;#34;); We can save a lot of boilerplate using local type inference to let java work out the type automatically:
package xyz.byexample.java10; public class Inference { public static void main(String[] args) { var variable = List.</description>
    </item>
    
    <item>
      <title>Java 8 Method References Examples</title>
      <link>https://byexample.xyz/java/8/methodreference/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://byexample.xyz/java/8/methodreference/</guid>
      <description>Basic Example Method references are probably most useful when used with the Stream API to apply a function to every element of a stream. For example we can use map() to make each element of a Stream&amp;lt;String&amp;gt; to upper case:
package xyz.byexample.java8; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Map { public static void main(String[] args) { List&amp;lt;String&amp;gt; letters = Arrays.asList(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;); List&amp;lt;String&amp;gt; upperCase = letters.stream() .map(String::toUpperCase) .</description>
    </item>
    
    <item>
      <title>Java 9 Modules</title>
      <link>https://byexample.xyz/java/9/modules/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://byexample.xyz/java/9/modules/</guid>
      <description>Intro Modules are a layer of abstraction above packages that allows you to group related packages together.
Since the entire JDK has been split into modules, and because you have to explicitly state which modules your own modules need, your own distributable will only contain the code it needs to by using modules.
 In the old pre-JDK9 days, your distributable would contain the entire Java Platform, which meant a lot of code you probably weren&amp;rsquo;t using (e.</description>
    </item>
    
    <item>
      <title>Java 8 Optional Examples</title>
      <link>https://byexample.xyz/java/8/optional/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://byexample.xyz/java/8/optional/</guid>
      <description>Optional&amp;lt;T&amp;gt; is useful in avoiding the unchecked NullPointerException as it provides a type-safe object that may or may not contain a value, and so it is up to the calling code to specifically check if there is a value or not. The idea is to force us to think about what to do when we&amp;rsquo;re writing code, rather than accidentally hitting a NullPointerException if a function returns null.
For example, Optional&amp;lt;T&amp;gt; is used a lot with the Stream API to force us to thoughtfully handle the situation where there might be an empty stream.</description>
    </item>
    
    <item>
      <title>Java 8 Streams Collect Examples</title>
      <link>https://byexample.xyz/java/8/collect/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://byexample.xyz/java/8/collect/</guid>
      <description>Collecting to a list package xyz.byexample.java8; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; import java.util.stream.Stream; public class Collect { public static void main(String[] args) { List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1, 2, 3, 4, 5); System.out.println(numbers.stream().collect(Collectors.toList())); } } Output
[1, 2, 3, 4, 5]  Collecting Average of Integers List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1, 2, 3, 4, 5); System.out.println( numbers.stream().collect(Collectors.averagingInt(Integer::intValue))); Output
3.0  Collecting Sum of Integers List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1, 2, 3, 4, 5); System.</description>
    </item>
    
    <item>
      <title>Java 8 Streams Filter Examples</title>
      <link>https://byexample.xyz/java/8/filters/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://byexample.xyz/java/8/filters/</guid>
      <description>Basic Filtering Filters allow you to easily remove elements from a stream that you&amp;rsquo;re not interested in.
For example if we had a list of numbers, we can filter out any that are less than 3.
package xyz.byexample.java8; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Filter { public static void main(String[] args) { List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(1,2,3,4,5); List&amp;lt;Integer&amp;gt; lessThanThree = numbers.stream() .filter((Integer number) -&amp;gt; { return number &amp;lt; 3; }) .</description>
    </item>
    
    <item>
      <title>Java 8 Streams Map &amp; FlatMap Examples</title>
      <link>https://byexample.xyz/java/8/map/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://byexample.xyz/java/8/map/</guid>
      <description>Map Examples We can use map() to execute a function on every element of a stream. The classic example for this one is applying toUpperCase() on every element.
package xyz.byexample.java8; import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Map { public static void main(String[] args) { List&amp;lt;String&amp;gt; letters = Arrays.asList(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;); List&amp;lt;String&amp;gt; upperCase = letters.stream() .map((String element) -&amp;gt; element.toUpperCase()) .collect(Collectors.toList()); System.out.println(upperCase); } } Output
[A, B, C]  If we want to make the code more compact, we can change this to use a method reference that references String&amp;rsquo;s toUpperCase() method and apply that directly to each element of the stream.</description>
    </item>
    
    <item>
      <title>Java 8 Streams findFirst &amp; findAny Examples</title>
      <link>https://byexample.xyz/java/8/find/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://byexample.xyz/java/8/find/</guid>
      <description>Getting the first element from a stream We can use findFirst() and findAny() to retrieve the first - or any - element from the stream. These return an Optional&amp;lt;T&amp;gt; object.
 findFirst() returns the first element in the stream, but findAny() does not guarantee any ordering and could return any element in the stream. This allows for maximum performance when using parallelStream() and if you dont care about ordering.</description>
    </item>
    
    <item>
      <title>Java 8 Streams forEach Examples</title>
      <link>https://byexample.xyz/java/8/foreach/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://byexample.xyz/java/8/foreach/</guid>
      <description>forEach on an Array Since an array in Java is not an Iterable, you cant directly use forEach() with it like you can with List, Map and other classes that implement the Iterable interface.
The workaround to this is to simply convert the array to a Stream first using the built-in Arrays.stream() function - see Converting from Streams to Arrays for more details on converting between arrays and streams.</description>
    </item>
    
  </channel>
</rss>